# Архитектура проекта MTS Design Weekend

## Общая структура
- Фронтенд-приложение на чистом JavaScript
- Адаптивный дизайн для настольных и мобильных устройств
- Модульная архитектура с разделением ответственности

## Основные модули

### Ядро приложения (core)
- Инициализация приложения
- Маршрутизация и переключение экранов
- Управление состоянием

### Модуль интерфейса (uiModule)
- Отображение и переключение экранов
- Компоненты интерфейса
- Анимации и переходы
- Тёмная и светлая темы

### Модуль предсказаний (predictionModule)
- Выбор карт (случайный или на основе изображения)
- Генерация предсказаний
- Визуализация карт и результатов
- Интеграция с API для генерации предсказаний

### Модуль API (apiModule)
- Интеграция с OpenAI API
- Настройка модели и параметров
- Генерация предсказаний по контексту карты
- Сохранение API-ключа и настроек
- Управление конфигурацией QR-кодов
- Базовая работа с QR-маппингами (соответствия QR-кодов картам)
- Синхронизация конфигурации API между устройствами через config.json
- Централизованное управление настройками API (apiBaseUrl, apiKey, apiModel и т.д.)

### Модуль синхронизации карт (cardSyncModule)
- Централизованный доступ к данным о картах
- Синхронизация QR-кодов и их соответствий картам между модулями
- Обеспечение единого источника данных для карт и QR-кодов
- Событийно-ориентированное взаимодействие через EventBus
- Актуализация данных между основным хранилищем и компонентами

### Модуль камеры (cameraModule)
- Доступ к камере устройства
- Захват изображения
- Распознавание QR-кодов на картах
- Отправка данных в модуль предсказаний

### Модуль статистики (statsModule)
- Отслеживание активности пользователей
- Сбор статистики использования
- Визуализация данных для администраторов

### Модуль утилит (utils)
- Общие функции и инструменты
- Форматирование данных
- Работа с локальным хранилищем
- Генерация уникальных идентификаторов

### Модуль EventBus
- Система событий для коммуникации между модулями
- Подписка и публикация событий
- Снижение связанности между компонентами

## Базы данных и хранение
- localStorage для сохранения настроек, сессий и карт
- Централизованный механизм синхронизации данных о картах между модулями
- Синхронизация настроек API и QR-кодов между устройствами
- Механизм перезагрузки данных при обновлениях
- Событийная модель обновления при изменении данных

## Страницы и экраны
- Главный экран (приветствие)
- Выбор карты (случайной или с камеры)
- Выбор вопроса
- Экран загрузки
- Экран результата
- Экран инфо и справка
- Административный интерфейс

## Процесс работы
1. Пользователь открывает приложение
2. Выбирает карту (случайную или фотографирует)
3. Приложение распознает карту по изображению или QR-коду
4. Пользователь задает вопрос
5. Система генерирует предсказание (локально или через API)
6. Пользователь может поделиться результатом

## Дополнительные возможности
- Тёмная тема
- Публикация предсказаний
- Отслеживание аналитики
- Административный интерфейс для управления
- Редактирование и настройка карт
- Настройка соответствий QR-кодов для карт, используемых на всех устройствах
- Централизованное управление данными карт через cardSyncModule
- Обновление административной панели в реальном времени при изменении данных
- Системный интерфейс для обновления данных карт

## Структура проекта

### 1. Фронтенд (Веб-приложение)
- **Модульная архитектура**: приложение разделено на независимые модули
- **HTML-страницы**:
  - `index.html` - основное приложение
  - `admin.html` - панель администратора
  - `cards-manager.html` - управление картами
  - `qr-generator.html` - генератор QR-кодов для карт

### 2. Модули приложения (js/modules/)
- **appModule.js** - координирует все модули, инициализирует приложение
- **uiManager.js** - управление UI, переключение экранов
- **cameraModule.js** - работа с камерой устройства
- **predictionModule.js** - логика предсказаний и работы с картами
- **statsModule.js** - сбор статистики использования
- **apiModule.js** - интеграция с внешними API и базовая работа с QR-кодами
- **cardSyncModule.js** - централизованное управление картами и QR-маппингами
- **mainPage.js** - логика главной страницы

### 3. Вспомогательные компоненты
- **js/cards-data.js** - данные о картах предсказаний
- **js/utils/logger.js** - утилита логирования
- **js/predictions.js** - алгоритмы генерации предсказаний
- **js/debug-panel.js** - панель отладки

### 4. Интеграция с Telegram
- **bot-example.js** - Telegram бот на Node.js (Telegraf)
- **start-bot.ps1** - скрипт для запуска бота
- **mts-design-cards-bot/** - дополнительные файлы бота

### 5. Ресурсы
- **css/** - стили приложения
- **img/cards/** - изображения карт

## Взаимодействие между модулями

1. **Загрузка и инициализация**:
   - `app-modular.js` -> загружает все модули в правильном порядке
   - `appModule.js` -> инициализирует все остальные модули и обеспечивает их взаимодействие

2. **Основные потоки данных**:
   - `uiManager.js` <-> `appModule.js` - для переключения экранов и UI-операций
   - `cameraModule.js` -> `predictionModule.js` - передача фотографии для анализа
   - `predictionModule.js` -> `statsModule.js` - отправка статистики использования
   - `cards-data.js` -> `cardSyncModule.js` - источник данных о картах
   - `cardSyncModule.js` -> используется всеми модулями для доступа к данным карт
   - `apiModule.js` <-> `cardSyncModule.js` - для синхронизации QR-маппингов

3. **События и обновления**:
   - EventBus - передача событий между модулями через подписку/публикацию
   - События обновления карт вызывают автоматическое обновление UI
   - События синхронизации координируют состояние данных между модулями

4. **Доступ к глобальным объектам**:
   - `window.app` - содержит ссылки на основные модули и состояние приложения
   - `window.uiManager`, `window.cameraModule`, `window.cardSyncModule` и др. - для прямого доступа к функциям модулей
   - `window.EventBus` - для публикации и подписки на события

## Принцип работы

1. **Инициализация**: 
   - `app-modular.js` загружает все модули в нужном порядке
   - `appModule.js` инициализирует приложение и настраивает взаимодействие модулей

2. **Поток пользователя**:
   - Пользователь открывает приложение через Telegram WebApp
   - Выбирает вопрос из предложенных 
   - Делает фото карты через камеру устройства
   - Получает генерируемое предсказание
   - Может поделиться результатом или начать заново

3. **Обработка изображений**:
   - Фото карты обрабатывается для распознавания (возможно, через QR-код)
   - Каждая карта имеет уникальный идентификатор и метафору
   - На основе идентификатора карты и вопроса генерируется предсказание

4. **Telegram интеграция**:
   - Бот предоставляет интерфейс WebApp через кнопку в меню
   - Обрабатывает данные, отправленные из WebApp
   - Поддерживает основные команды (/start, /help, /cards, /about)

## Технический стек
- **Frontend**: HTML, CSS, JavaScript (ванильный)
- **Backend**: Node.js (Telegraf для Telegram Bot API)
- **Деплой**: статический хостинг и отдельный хостинг для бота

## Дополнительные особенности
- Приложение адаптировано для Telegram WebApp API (темы, размеры)
- Поддержка темной/светлой темы
- Работа с камерой устройства
- Возможность поделиться результатами
- Статистика использования
- Админ-панель для управления 

## Интеграция с внешними API
- **apiModule.js** - модуль для работы с внешними API (OpenAI)
  - Загрузка API ключей из локального хранилища
  - Генерация предсказаний через API
  - Мониторинг использования API
  - Логирование запросов и ответов

- **Безопасность API ключей**:
  - Хранение в localStorage пользователя и централизованном config.json
  - Отсутствие ключей в исходном коде
  - Управление ключами через админ-интерфейс
  - Шифрование ключей при необходимости

- **Система кросс-устройственной конфигурации API**:
  - Централизованное хранение настроек в файле config.json
  - Синхронизация настроек между устройствами при загрузке приложения
  - Обновление настроек через специальный интерфейс api-settings.html
  - Сохранение изменений через серверный скрипт save-config.php
  - Глобальная конфигурация доступна через window.APP_CONFIG
  - Приоритет глобальной конфигурации над локальными настройками
  - Обратная совместимость с локальными настройками в localStorage

- **Статистика использования API**:
  - Количество запросов
  - Потребление токенов
  - Процент успешных запросов
  - Детализация истории запросов

## Расширение приложения

### 1. Добавление новых карт
1. Добавить изображение карты в директорию `img/cards/` (формат PNG, именование pattern: cardXXX.png)
2. Обновить данные карты в файле `js/cards-data.js`, добавив новый объект в формате:
   ```javascript
   'cardXXX': {
     title: 'НАЗВАНИЕ_КАРТЫ',
     description: 'Описание карты и метафора'
   }
   ```
3. Если используется QR-код, сгенерировать его через `qr-generator.html`

### 2. Добавление новых экранов UI
1. Добавить разметку нового экрана в `index.html` с классом `app-screen` и id `[имя]-screen`
2. Добавить функции переключения экрана в `js/modules/uiManager.js`
3. Добавить обработчики событий в `js/modules/appModule.js` (функция setupEventListeners)

### 3. Создание нового модуля
1. Создать файл `js/modules/[имяМодуля].js`
2. Добавить базовую структуру модуля:
   ```javascript
   // Объявление глобального объекта
   window.[имяМодуля] = {
     // Свойства и методы
     init: function() {
       // Инициализация модуля
     }
   };
   ```
3. Добавить модуль в массив загрузки в `js/app-modular.js`
4. Интегрировать с appModule.js для координации с другими модулями

### 4. Расширение функциональности бота
1. Добавить новые команды в `bot-example.js` через метод `bot.command()`
2. Для интеграции с веб-приложением, добавить обработку новых типов данных в обработчик `web_app_data`
3. Обновить информационные команды (/help, /about) для отражения новой функциональности

### 5. Форматы данных
- **Карта**: id (cardXXX), title (название), description (описание/метафора)
- **Вопрос**: id, text (текст вопроса), category (категория)
- **Предсказание**: комбинация данных карты, вопроса и генерируемого текста

### 6. Файлы кросс-устройственной конфигурации
- **config.json** - централизованное хранилище настроек API
  ```json
  {
    "apiBaseUrl": "https://api.openai.com/v1",
    "apiKey": "", // API ключ пользователя
    "apiModel": "gpt-3.5-turbo",
    "isApiEnabled": false,
    "temperature": 0.7,
    "systemPrompt": "Шаблон системного промпта",
    "lastUpdated": "Временная метка последнего обновления"
  }
  ```

- **save-config.php** - серверный скрипт для сохранения настроек
  - Принимает POST-запросы с JSON-данными
  - Проверяет валидность данных
  - Сохраняет конфигурацию в файл config.json
  - Обеспечивает атомарность операций записи конфигурации

## Процесс конфигурации API

1. **Загрузка конфигурации**:
   - `app-main.js` -> загружает конфигурацию из config.json при старте приложения
   - Создает глобальный объект window.APP_CONFIG с загруженными настройками
   - При ошибке загрузки используются локальные настройки из localStorage

2. **Применение настроек**:
   - `apiModule.js` -> инициализируется с настройками из window.APP_CONFIG
   - Настройки синхронизируются между всеми источниками (config.json, localStorage)
   - Приоритет имеют настройки из config.json как наиболее актуальные

3. **Обновление настроек**:
   - Через интерфейс api-settings.html администратор обновляет настройки API
   - Изменения сохраняются в config.json через save-config.php
   - Обновления применяются на всех устройствах при перезагрузке приложения

4. **Безопасность**:
   - Конфиденциальные данные (API ключи) могут быть защищены при необходимости
   - Доступ к интерфейсу настроек ограничен администраторами
   - Валидация входных данных для предотвращения инъекций

## Размещение на Cloudflare Pages

### Особенности и ограничения размещения на Cloudflare Pages

1. **Отсутствие поддержки PHP**:
   - Cloudflare Pages не поддерживает выполнение PHP-скриптов
   - Реализован JavaScript-механизм ConfigManager для замены функций PHP
   - Настройки хранятся в localStorage браузера вместо централизованного файла config.json

2. **Механизм перенаправления запросов**:
   - Файл `_redirects` для перенаправления запросов к PHP на соответствующие HTML-страницы
   - Использование кода 200 вместо 301 для возможности обработки запросов JavaScript
   - Файл `_headers` для настройки CORS-заголовков и политик безопасности

3. **ConfigManager.js**:
   - Модуль для управления конфигурацией без использования PHP
   - Использует localStorage для хранения настроек
   - Предоставляет методы экспорта/импорта настроек через файлы .json
   - Интегрируется с существующим модулем API через перехват методов

4. **Процесс деплоя**:
   - Специальные скрипты для деплоя: `cloudflare-deploy.ps1` (Windows) и `cloudflare-deploy.sh` (Mac/Linux)
   - Поддержка деплоя через Wrangler CLI или создание ZIP-архива
   - Автоматическое исключение ненужных файлов при деплое

### Интеграция с существующей архитектурой

1. **Обратная совместимость**:
   - ConfigManager поддерживает обратную совместимость с существующими методами сохранения
   - Перехват метода apiModule.saveConfigToFile для использования ConfigManager
   - Синхронизация с существующими хранилищами (localStorage, window.APP_CONFIG)

2. **События конфигурации**:
   - Использование EventBus для публикации событий обновления конфигурации
   - События: CONFIG_SAVED, CONFIG_SAVE_ERROR, CONFIG_IMPORTED, CONFIG_CLEARED
   - Обработчики событий для обновления UI и других модулей

3. **Приоритет источников данных**:
   - localStorage > window.APP_CONFIG > значения по умолчанию
   - Автоматическое восстановление из резервной копии при сбоях
   - Сохранение истории изменений с метками времени

### Расширение возможностей хранения настроек

1. **Экспорт/импорт конфигурации**:
   - Возможность экспорта настроек в файл .json
   - Импорт настроек из файла .json
   - Опциональное включение/исключение API-ключей в экспортируемые данные

2. **Безопасность данных**:
   - Валидация импортируемых конфигураций
   - Защита от некорректных форматов данных
   - Подтверждение экспорта чувствительных данных